# Sharing Secrets with MCP Servers

## The Problem

When you run multiple Claude Code projects, each with its own MCP servers, you quickly hit a secrets management problem. The common approaches all have significant downsides:

**Copy a `.env` into every project.** This works until you rotate an API key and realize it's duplicated across 8 projects. You update 7 of them. The 8th breaks at 2am. Worse, every `.env` is a potential git accident — one missing `.gitignore` entry and your keys are in the commit history.

**Export everything in your shell profile.** Adding `export GITHUB_TOKEN=...` to `.bashrc` means every process on your machine sees every secret. Your blog project has access to your production database credentials. There's no isolation and no way to audit which project uses what.

**Hardcode secrets in `.mcp.json`.** MCP server configs support `env` blocks, and it's tempting to paste values directly. But `.mcp.json` is committed to git — your team needs it for the MCP server definitions. Now you're choosing between sharing the config or protecting the secrets.

**Use a single global `.env` with dotenv.** Better than shell exports, but you still have no per-project access control. Every project loads the same file and sees everything. When a project only needs a GitHub token, it also gets your Stripe key, your database URL, and your Slack webhook.

The core tension: MCP servers need secrets as environment variables, but there's no standard way to give each project only the secrets it needs — without duplicating files, polluting your shell, or committing credentials.

## The Solution

Two mechanisms exist, for two different workflows:

| Workflow | Mechanism | How secrets reach MCP |
|----------|-----------|----------------------|
| `pilotlynx run <project> <workflow>` | Runtime injection | PilotLynx injects secrets into the Agent SDK subprocess directly |
| Direct Claude Code in project dir | direnv | `.envrc` exports secrets into the shell; Claude Code and MCP servers inherit them |

Both mechanisms apply the same **secrets access policy** — a project only ever sees what it's allowed to see.

## Setup Guide

### Prerequisites

- A PilotLynx workspace (created with `pilotlynx init`)
- At least one project (created with `pilotlynx project create` or `pilotlynx project add`)
- [direnv](https://direnv.net/) installed for direct access (`brew install direnv` / `apt install direnv`)

### Step 1: Add secrets to the central .env

All secrets live in one place:

```bash
# pilotlynx/.env
ANTHROPIC_API_KEY=sk-ant-...
GITHUB_TOKEN=ghp_...
SLACK_WEBHOOK=https://hooks.slack.com/...
DATABASE_URL=postgres://...
```

This file is gitignored by default.

### Step 2: Define the access policy

Edit `pilotlynx/shared/policies/secrets-access.yaml`:

```yaml
version: 1

# Secrets available to ALL projects
shared:
  - ANTHROPIC_API_KEY

# Per-project overrides
projects:
  my-web-app:
    allowed:
      - GITHUB_TOKEN
      - DATABASE_URL
    mappings:
      # Rename: the project sees SLACK_URL, sourced from SLACK_WEBHOOK in .env
      SLACK_URL: SLACK_WEBHOOK

  my-cli-tool:
    allowed:
      - GITHUB_TOKEN
    # no mappings — just the shared + allowed keys
```

**Policy rules:**
- A project receives: `shared` keys + its `allowed` keys + its `mappings`
- Keys not listed are invisible to the project
- If a key is in the policy but missing from `.env`, it's silently skipped
- If no policy file exists, projects receive **no secrets at all**

### Step 3: Verify what a project can see

```bash
pilotlynx env my-web-app
# ANTHROPIC_API_KEY="sk-ant-..."
# GITHUB_TOKEN="ghp_..."
# DATABASE_URL="postgres://..."
# SLACK_URL="https://hooks.slack.com/..."

pilotlynx env my-cli-tool
# ANTHROPIC_API_KEY="sk-ant-..."
# GITHUB_TOKEN="ghp_..."
```

Other output formats:

```bash
pilotlynx env my-web-app --export    # export KEY=value (shell)
pilotlynx env my-web-app --json      # {"KEY": "value"}
pilotlynx env my-web-app --envrc     # .envrc format with PILOTLYNX_ROOT
```

### Step 4: Link the project for direct access

```bash
pilotlynx link my-web-app --direnv
```

This does two things:

1. **Updates `.claude/settings.json`** in the project — adds `PILOTLYNX_ROOT` so `pilotlynx` CLI commands work from inside the project directory.

2. **Generates `.envrc`** in the project directory — contains `export` statements for every policy-filtered secret. The file looks like:

```bash
# Generated by PilotLynx — do not edit
# Re-run: pilotlynx link my-web-app --direnv
export PILOTLYNX_ROOT=/home/you/workspace/pilotlynx
export ANTHROPIC_API_KEY=sk-ant-...
export GITHUB_TOKEN=ghp_...
export DATABASE_URL=postgres://...
export SLACK_URL=https://hooks.slack.com/...
```

### Step 5: Activate direnv

```bash
cd my-web-app
direnv allow
```

From this point, every process started in this directory (including Claude Code and its MCP servers) inherits these environment variables.

### Step 6: Configure MCP servers

In the project's `.mcp.json`, MCP servers can reference secrets via standard environment variable syntax:

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
      }
    },
    "postgres": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres", "${DATABASE_URL}"]
    }
  }
}
```

Claude Code expands `${VAR}` references from the shell environment when launching MCP server processes.

## Migrating Secrets from Existing Projects

When you adopt an existing project with `pilotlynx project add`, secrets are **automatically detected and consolidated**.

### What happens

During `pilotlynx project add`, the CLI scans the project for secrets in two places:

1. **Project `.env` file** — parsed for key-value pairs
2. **`.mcp.json` env blocks** — scanned for literal values (existing `${VAR}` references are left alone)

Each detected key is compared against the central `pilotlynx/.env`:

| Situation | Action |
|-----------|--------|
| Key not in central `.env` | **New** — will be appended to central `.env` |
| Same key + same value in central `.env` | **Deduplicated** — just adds a policy entry |
| Same key + different value | **Conflict** — skipped with a warning |

The CLI then shows the detected key names (never values) and asks for confirmation:

```
Secrets detected in project:
  From .env:
    GITHUB_TOKEN
    DATABASE_URL
  From .mcp.json:
    SENDGRID_KEY
  1 key(s) already in central store (same value)
  2 new key(s) to add to central store

Consolidate 3 key(s) into central store? [Y/n]
```

If you confirm, the migration:
- Backs up the project `.env` to `.env.pilotlynx-backup`
- Appends new keys to `pilotlynx/.env`
- Rewrites `.mcp.json` literals to `${VAR}` references
- Updates `secrets-access.yaml` with the project's allowed keys
- Removes the project `.env`

### Handling conflicts

When the same key exists in both the project and central `.env` with different values (e.g., a staging vs. production token), the migration skips that key and warns you. To resolve manually:

1. Choose a distinct key name for the central `.env`:
   ```bash
   # pilotlynx/.env — two different tokens
   GITHUB_TOKEN=ghp_production
   GITHUB_TOKEN_STAGING=ghp_staging456
   ```

2. Use a policy mapping so the project sees it under the expected name:
   ```yaml
   # secrets-access.yaml
   projects:
     my-staging-app:
       mappings:
         GITHUB_TOKEN: GITHUB_TOKEN_STAGING
   ```

### After migration

The project's original `.env` is preserved as `.env.pilotlynx-backup` in case you need to reference it. Once you've verified everything works, you can delete the backup.

Link the project for direct access with direnv:

```bash
pilotlynx link my-existing-app --direnv
cd my-existing-app && direnv allow
```

## How It Works

```
pilotlynx/.env                     One file, all secrets (gitignored)
       |
       v
secrets-access.yaml                Per-project allowlist (committed, reviewable)
       |
       v
pilotlynx link --direnv                Generates .envrc with only allowed secrets
       |
       v
direnv allow                       Exports vars into the shell
       |
       v
claude (Claude Code)               Inherits shell environment
       |
       v
MCP servers (.mcp.json)            Inherit env from Claude Code process
```

There is no special MCP integration. MCP servers get secrets through standard Unix process environment inheritance — direnv populates the shell, Claude Code inherits it, MCP server child processes inherit from Claude Code.

## Maintenance

### When secrets change

Regenerate the `.envrc`:

```bash
pilotlynx link my-web-app --direnv
cd my-web-app && direnv allow
```

### When the policy changes

Same — regenerate `.envrc` since the set of allowed keys may have changed.

### Unlinking a project

```bash
pilotlynx unlink my-web-app
```

Removes `PILOTLYNX_ROOT` from `.claude/settings.json` and deletes the `.envrc` file.

## Security Notes

- `.envrc` files are created with restricted permissions (mode 0600).
- The `.envrc` is gitignored in the project template. Verify it's not tracked before committing.
- Secrets never appear in logs, skills, memory files, or any committed file.
- The policy file (`secrets-access.yaml`) is committed — changes to secret access are code-reviewable.
- `pilotlynx env` lets you audit exactly what each project can see at any time.
- Without a policy file, projects receive zero secrets — the default is deny-all.
