import { existsSync, readFileSync, writeFileSync, mkdirSync, unlinkSync } from 'node:fs';
import { join } from 'node:path';
import { isRegistered, resolveProjectPath } from '../registry.js';
import { buildProjectEnv } from '../secrets.js';
import { getConfigRoot } from '../config.js';
import { formatEnvrc } from './env-ops.js';

const ENVRC_MARKER = '# Generated by PilotLynx';

export interface LinkResult {
  success: boolean;
  error?: string;
  updatedSettings?: boolean;
  generatedEnvrc?: boolean;
  secretCount?: number;
}

export interface UnlinkResult {
  success: boolean;
  error?: string;
  removedSettings?: boolean;
  removedEnvrc?: boolean;
}

function updateSettingsEnv(projectDir: string, configRoot: string): void {
  const settingsPath = join(projectDir, '.claude', 'settings.json');
  let settings: Record<string, unknown> = {};

  if (existsSync(settingsPath)) {
    settings = JSON.parse(readFileSync(settingsPath, 'utf8'));
  } else {
    mkdirSync(join(projectDir, '.claude'), { recursive: true });
  }

  const env = (settings.env as Record<string, string>) ?? {};
  env.PILOTLYNX_ROOT = configRoot;
  settings.env = env;

  writeFileSync(settingsPath, JSON.stringify(settings, null, 2) + '\n', 'utf8');
}

function writeEnvrcFile(projectDir: string, env: Record<string, string>, configRoot: string): void {
  writeFileSync(
    join(projectDir, '.envrc'),
    formatEnvrc(env, configRoot),
    { encoding: 'utf8', mode: 0o600 },
  );
}

function removeSettingsEnv(projectDir: string): boolean {
  const settingsPath = join(projectDir, '.claude', 'settings.json');
  if (!existsSync(settingsPath)) return false;

  const settings = JSON.parse(readFileSync(settingsPath, 'utf8'));
  const env = settings.env as Record<string, string> | undefined;
  if (!env || !('PILOTLYNX_ROOT' in env)) return false;

  delete env.PILOTLYNX_ROOT;
  settings.env = env;
  writeFileSync(settingsPath, JSON.stringify(settings, null, 2) + '\n', 'utf8');
  return true;
}

function removeEnvrc(projectDir: string): boolean {
  const envrcPath = join(projectDir, '.envrc');
  if (!existsSync(envrcPath)) return false;

  const content = readFileSync(envrcPath, 'utf8');
  if (!content.includes(ENVRC_MARKER)) return false;

  unlinkSync(envrcPath);
  return true;
}

export function executeLink(project: string, opts: { direnv?: boolean }): LinkResult {
  if (!isRegistered(project)) {
    return { success: false, error: `Project "${project}" is not registered.` };
  }

  const projectDir = resolveProjectPath(project);
  const configRoot = getConfigRoot();

  updateSettingsEnv(projectDir, configRoot);

  let secretCount: number | undefined;
  let generatedEnvrc = false;
  if (opts.direnv) {
    const env = buildProjectEnv(project);
    writeEnvrcFile(projectDir, env, configRoot);
    secretCount = Object.keys(env).length;
    generatedEnvrc = true;
  }

  return { success: true, updatedSettings: true, generatedEnvrc, secretCount };
}

export function executeUnlink(project: string): UnlinkResult {
  if (!isRegistered(project)) {
    return { success: false, error: `Project "${project}" is not registered.` };
  }

  const projectDir = resolveProjectPath(project);
  const removedSettings = removeSettingsEnv(projectDir);
  const removedEnvrc = removeEnvrc(projectDir);

  return { success: true, removedSettings, removedEnvrc };
}
